/*
 * Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from "@angular/core";
import { Subject } from "rxjs/Subject";
import { PageCollectionService } from "./page-collection";
import { ButtonHubService } from "./button-hub";
import { GHOST_PAGE_ANIMATION } from "../../modal/utils/ghost-page-animations";
var WizardNavigationService = (function () {
    function WizardNavigationService(pageCollection, buttonService) {
        var _this = this;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
        // lets other components subscribe to when the current page changes
        this._currentChanged = new Subject();
        this.navServiceLoaded = false;
        this._movedToNextPage = new Subject();
        this._wizardFinished = new Subject();
        // When called, the wizard will move to the prev page.
        // This is a public function that can be used to programmatically go back
        // to the previous step.
        this._movedToPreviousPage = new Subject();
        this._cancelWizard = new Subject();
        this.wizardHasAltCancel = false;
        this._wizardGhostPageState = GHOST_PAGE_ANIMATION.STATES.NO_PAGES;
        this._hideWizardGhostPages = true;
        this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
            var currentPage = _this.currentPage;
            if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                return;
            }
            currentPage.previousButtonClicked.emit(currentPage);
            if (!currentPage.preventDefault) {
                _this.previous();
            }
        });
        this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
            var currentPage = _this.currentPage;
            if (!_this.currentPageIsLast && currentPage.readyToComplete) {
                currentPage.primaryButtonClicked.emit("next");
                currentPage.nextButtonClicked.emit(currentPage);
                if (currentPage.preventDefault) {
                    _this.pageCollection.commitPage(currentPage);
                }
                else {
                    _this.next();
                }
            }
        });
        this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
            var currentPage = _this.currentPage;
            if (!currentPage.readyToComplete) {
                return;
            }
            // because we made it past the guard up there ^ we know the current page is ready
            if (_this.currentPageIsLast) {
                currentPage.primaryButtonClicked.emit("danger");
                currentPage.dangerButtonClicked.emit(currentPage);
                if (currentPage.preventDefault) {
                    _this.pageCollection.commitPage(currentPage);
                }
                else {
                    _this.finish();
                }
            }
            else {
                currentPage.primaryButtonClicked.emit("danger");
                currentPage.dangerButtonClicked.emit(currentPage);
                if (currentPage.preventDefault) {
                    _this.pageCollection.commitPage(currentPage);
                }
                else {
                    _this.next();
                }
            }
        });
        this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
            var currentPage = _this.currentPage;
            if (currentPage.readyToComplete && _this.currentPageIsLast) {
                if (currentPage.preventDefault) {
                    _this.pageCollection.commitPage(currentPage);
                }
                else {
                    _this.finish();
                }
            }
        });
        this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
            _this.currentPage.customButtonClicked.emit(type);
        });
        this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
            if (_this.currentPage.preventDefault) {
                _this.currentPage.pageOnCancel.emit(_this.currentPage);
            }
            else {
                _this.cancel();
            }
            // SPECME
        });
        this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
            _this.setLastEnabledPageCurrent();
        });
    }
    WizardNavigationService.prototype.ngOnDestroy = function () {
        this.previousButtonSubscription.unsubscribe();
        this.nextButtonSubscription.unsubscribe();
        this.dangerButtonSubscription.unsubscribe();
        this.finishButtonSubscription.unsubscribe();
        this.customButtonSubscription.unsubscribe();
        this.cancelButtonSubscription.unsubscribe();
        this.pagesResetSubscription.unsubscribe();
    };
    Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
        get: function () {
            return this._currentChanged.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
        get: function () {
            return this.currentPage.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
        get: function () {
            return this.pageCollection.firstPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsNextToLast", {
        get: function () {
            return this.pageCollection.penultimatePage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
        get: function () {
            return this.pageCollection.lastPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.setCurrentPage = function (page) {
        this.currentPage = page;
        // TODO: emit page onload here
        this._currentChanged.next(page);
    };
    Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
        get: function () {
            return this._movedToNextPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
        get: function () {
            return this._wizardFinished.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    // next --
    //
    // When called, after successful validation, the wizard will move to the
    // next page.
    // This is a public function that can be used to programmatically advance
    // the user to the next page.
    WizardNavigationService.prototype.next = function () {
        var currentPage = this.currentPage;
        var nextPage;
        if (this.currentPageIsLast) {
            this.finish();
        }
        if (!currentPage.readyToComplete) {
            return;
        }
        if (!currentPage.preventDefault) {
            // when preventDefault is enacted, this is called manually
            // after an onCommit. put check in here to avoid duplicate
            // onCommit calls
            this.pageCollection.commitPage(currentPage);
        }
        nextPage = this.pageCollection.getNextPage(currentPage);
        // catch errant null or undefineds that creep in
        if (nextPage) {
            this.setCurrentPage(nextPage);
            this._movedToNextPage.next(true);
        }
        else {
            throw new Error("The wizard has no next page to go to.");
        }
    };
    WizardNavigationService.prototype.finish = function () {
        var currentPage = this.currentPage;
        if (!currentPage.readyToComplete) {
            return;
        }
        currentPage.primaryButtonClicked.emit("finish");
        currentPage.finishButtonClicked.emit(currentPage);
        if (!currentPage.preventDefault) {
            // when preventDefault is enacted, this is called manually
            // after an onCommit. put check in here to avoid duplicate
            // onCommit calls
            this.pageCollection.commitPage(currentPage);
        }
        this._wizardFinished.next();
    };
    Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
        get: function () {
            return this._movedToPreviousPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.previous = function () {
        var previousPage;
        if (this.currentPageIsFirst) {
            return;
        }
        previousPage = this.pageCollection.getPreviousPage(this.currentPage);
        if (!previousPage) {
            return;
        }
        this._movedToPreviousPage.next(true);
        this.setCurrentPage(previousPage);
    };
    Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
        get: function () {
            return this._cancelWizard.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.cancel = function () {
        this._cancelWizard.next();
    };
    WizardNavigationService.prototype.goTo = function (pageToGoToOrId) {
        var pageToGoTo;
        var currentPage;
        var myPages;
        var pagesToCheck;
        var okayToMove = true;
        myPages = this.pageCollection;
        if (typeof pageToGoToOrId === "string") {
            // we have an ID so we need to look up our page
            pageToGoTo = myPages.getPageById(pageToGoToOrId);
        }
        else {
            pageToGoTo = pageToGoToOrId;
        }
        currentPage = this.currentPage;
        if (pageToGoTo === currentPage) {
            return;
        }
        else {
            pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
        }
        pagesToCheck.forEach(function (page) {
            if (!okayToMove) {
                return;
            }
            if (!page.completed && !page.current) {
                okayToMove = false;
            }
        });
        if (!okayToMove) {
            return;
        }
        this.setCurrentPage(pageToGoTo);
    };
    WizardNavigationService.prototype.setLastEnabledPageCurrent = function () {
        var allPages = this.pageCollection.pagesAsArray;
        var lastCompletedPageIndex = null;
        allPages.forEach(function (page, index) {
            if (page.completed) {
                lastCompletedPageIndex = index;
            }
        });
        if (lastCompletedPageIndex === null) {
            // always is at least the first item...
            lastCompletedPageIndex = 0;
        }
        else if ((lastCompletedPageIndex + 1) < allPages.length) {
            lastCompletedPageIndex = lastCompletedPageIndex + 1;
        }
        this.setCurrentPage(allPages[lastCompletedPageIndex]);
    };
    // used to reset to the first page
    // SPECME: TEST FOR IF ARRAY OF PAGES CHANGE AFTER RESET HAPPENS
    // ID...
    // TODO?: EASIEST WAY TO SOLVE IS TO HAVE A GENERIC INPUT TO RESET TO A SPECIFIC ID
    WizardNavigationService.prototype.setFirstPageCurrent = function () {
        this.setCurrentPage(this.pageCollection.pagesAsArray[0]);
    };
    Object.defineProperty(WizardNavigationService.prototype, "wizardGhostPageState", {
        get: function () {
            return this._wizardGhostPageState;
        },
        set: function (value) {
            if (this.hideWizardGhostPages) {
                this._wizardGhostPageState = GHOST_PAGE_ANIMATION.STATES.NO_PAGES;
            }
            else {
                this._wizardGhostPageState = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "hideWizardGhostPages", {
        get: function () {
            return this._hideWizardGhostPages;
        },
        set: function (value) {
            this._hideWizardGhostPages = value;
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.updateNavigation = function () {
        var toSetCurrent;
        var currentPageRemoved;
        this.pageCollection.updateCompletedStates();
        currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
        toSetCurrent = this.pageCollection.findFirstIncompletePage();
        this.setCurrentPage(toSetCurrent);
    };
    return WizardNavigationService;
}());
export { WizardNavigationService };
WizardNavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
WizardNavigationService.ctorParameters = function () { return [
    { type: PageCollectionService, },
    { type: ButtonHubService, },
]; };
//# sourceMappingURL=wizard-navigation.js.map